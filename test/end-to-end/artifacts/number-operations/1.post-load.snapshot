export 0 = &function run;

slot ['global:Infinity'] = Infinity;
slot ['global:NaN'] = NaN;
slot ['global:Number'] = &allocation 6;
slot ['global:assert'] = host function 2;
slot ['global:assertEqual'] = host function 3;
slot ['global:overflowChecks'] = true;
slot testAddition = &function testAddition;
slot testDivision = &function testDivision;
slot testFloatToString = &function testFloatToString;
slot testGreaterThan = &function testGreaterThan;
slot testIncrDecr = &function testIncrDecr;
slot testIntToString = &function testIntToString;
slot testLessThan = &function testLessThan;
slot testMultiplication = &function testMultiplication;
slot testNegate = &function testNegate;
slot testPower = &function testPower;
slot testRemainder = &function testRemainder;
slot testStringToInt = &function testStringToInt;
slot testSubtraction = &function testSubtraction;
slot testUnaryPlus = &function testUnaryPlus;

function Number_isNaN() {
  entry:
    // NaN is the only value that is not equal to itself
    LoadArg(index 1);
    LoadArg(index 1);
    BinOp(op '!==');
    // NaN is the only value that is not equal to itself
    Return();
}

function run() {
  entry:
    LoadGlobal(name 'testNegate');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testUnaryPlus');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testAddition');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testSubtraction');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testMultiplication');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testDivision');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testLessThan');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testGreaterThan');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testRemainder');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testPower');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testIncrDecr');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testStringToInt');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testIntToString');
    Literal(lit undefined);
    Call(count 1, flag true);
    LoadGlobal(name 'testFloatToString');
    Literal(lit undefined);
    Call(count 1, flag true);
    Literal(lit undefined);
    Return();
}

function testAddition() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '+');
    Literal(lit 5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '+');
    Literal(lit 5000);
    Call(count 3, flag true);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 3500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3, flag true);
    // 12 bit addition (should not overflow, but should take the fast path still)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6000);
    Literal(lit 500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3, flag true);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 500);
    Literal(lit 6500);
    BinOp(op '+');
    Literal(lit 7000);
    Call(count 3, flag true);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '+');
    Literal(lit 18000);
    Call(count 3, flag true);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '+');
    Literal(lit 150000);
    Call(count 3, flag true);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7500);
    Literal(lit 7000);
    BinOp(op '+');
    Literal(lit 14500);
    Call(count 3, flag true);
    // overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2000000000);
    Literal(lit 2000000000);
    BinOp(op '+');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block4, @block5);
  block4:
    Literal(lit 4000000000);
    Jump(@block6);
  block5:
    Literal(lit -294967296);
    Jump(@block6);
  block6:
    Call(count 3, flag true);
    // overflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1.5);
    Literal(lit 1);
    BinOp(op '+');
    Literal(lit -0.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit 0.5);
    BinOp(op '+');
    Literal(lit -1.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -5000000000);
    Literal(lit 4999999000);
    BinOp(op '+');
    Literal(lit -1000);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testDivision() {
  entry:
    // Floating point division (the normal)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op '/');
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op '/');
    Literal(lit 3.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op '/');
    Literal(lit 3.4);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 3, flag true);
    // Without overflow checks enabled, the negation of integer zero is integer zero
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '-');
    UnOp(op '-');
    BinOp(op '/');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block13, @block14);
  block13:
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Jump(@block15);
  block14:
    LoadGlobal(name 'global:Infinity');
    Jump(@block15);
  block15:
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op '/');
    Call(count 2, flag false);
    Call(count 2, flag true);
    // Integer division
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit -3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit -2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit -2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:NaN');
    LoadGlobal(name 'global:NaN');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testFloatToString() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    LoadGlobal(name 'global:NaN');
    BinOp(op '+');
    Literal(lit 'NaN');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    LoadGlobal(name 'global:Infinity');
    BinOp(op '+');
    Literal(lit 'Infinity');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    BinOp(op '+');
    Literal(lit '-Infinity');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -0);
    BinOp(op '+');
    Literal(lit '0');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 0.1);
    BinOp(op '+');
    Literal(lit '0.1');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -0.1);
    BinOp(op '+');
    Literal(lit '-0.1');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 1e+30);
    BinOp(op '+');
    Literal(lit '1e+30');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -1e+30);
    BinOp(op '+');
    Literal(lit '-1e+30');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 1e-30);
    BinOp(op '+');
    Literal(lit '1e-30');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -1e-30);
    BinOp(op '+');
    Literal(lit '-1e-30');
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testGreaterThan() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3, flag true);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testIncrDecr() {
  entry:
    Literal(lit deleted);
    Literal(lit 1);
    StoreVar(index 0);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 3);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    Call(count 3, flag true);
    Literal(lit 1.5);
    LoadVar(index 1);
    StoreVar(index 0);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 2.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1.5);
    Call(count 3, flag true);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testIntToString() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 0);
    BinOp(op '+');
    Literal(lit '0');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 1);
    BinOp(op '+');
    Literal(lit '1');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -1);
    BinOp(op '+');
    Literal(lit '-1');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit 2147483647);
    BinOp(op '+');
    Literal(lit '2147483647');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    Literal(lit -2147483648);
    BinOp(op '+');
    Literal(lit '-2147483648');
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testLessThan() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3, flag true);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testMultiplication() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5.5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 33);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit -30);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000);
    Literal(lit 5000);
    BinOp(op '*');
    Literal(lit 25000000);
    Call(count 3, flag true);
    // Overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 17000);
    Literal(lit 2);
    BinOp(op '*');
    Literal(lit 34000);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000);
    Literal(lit 5000000);
    BinOp(op '*');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block10, @block11);
  block10:
    Literal(lit 25000000000000);
    Jump(@block12);
  block11:
    Literal(lit -1004630016);
    Jump(@block12);
  block12:
    Call(count 3, flag true);
    // Overflow 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 25000000000000);
    Literal(lit 1);
    BinOp(op '*');
    Literal(lit 25000000000000);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testNegate() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '-');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Literal(lit -1.1);
    Literal(lit 0);
    BinOp(op '/');
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2147483648);
    UnOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 2147483648);
    Jump(@block3);
  block2:
    Literal(lit -2147483648);
    Jump(@block3);
  block3:
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testPower() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '**');
    Literal(lit 8);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0);
    BinOp(op '**');
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.5);
    Literal(lit 1);
    BinOp(op '**');
    Literal(lit 2.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit 1);
    LoadGlobal(name 'global:Infinity');
    BinOp(op '**');
    Call(count 2, flag false);
    Call(count 2, flag true);
    Literal(lit undefined);
    Return();
}

function testRemainder() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 550);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.25);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5.25);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 550.25);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit 4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit 3.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit 5);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit 5.1);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2, flag false);
    Call(count 2, flag true);
    Literal(lit undefined);
    Return();
}

function testStringToInt() {
  entry:
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit 'x');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit 'length');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit '__proto__');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit '1a');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit '1.1.1');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit '123456789123456789.1.1');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 3);
    Literal(lit 'isNaN');
    ObjectGet();
    StoreVar(index 2);
    Literal(lit '123\u0000');
    UnOp(op '+');
    Call(count 2, flag false);
    Call(count 2, flag true);
    // Empty string
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '');
    UnOp(op '+');
    Literal(lit 0);
    Call(count 3, flag true);
    // Whitespace
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '  ');
    UnOp(op '+');
    Literal(lit 0);
    Call(count 3, flag true);
    // Small integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '123');
    UnOp(op '+');
    Literal(lit 123);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '-123');
    UnOp(op '+');
    Literal(lit -123);
    Call(count 3, flag true);
    // Leading and trailing whitespace
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '  123   ');
    UnOp(op '+');
    Literal(lit 123);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '  -123   ');
    UnOp(op '+');
    Literal(lit -123);
    Call(count 3, flag true);
    // Int32
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '12345678');
    UnOp(op '+');
    Literal(lit 12345678);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit '-12345678');
    UnOp(op '+');
    Literal(lit -12345678);
    Call(count 3, flag true);
    // Multiply
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit '123');
    BinOp(op '*');
    Literal(lit 123);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testSubtraction() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '-');
    Literal(lit 1);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3, flag true);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '-');
    Literal(lit 2000);
    Call(count 3, flag true);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '-');
    Literal(lit 10000);
    Call(count 3, flag true);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7500);
    Literal(lit 7000);
    BinOp(op '-');
    Literal(lit -14500);
    Call(count 3, flag true);
    // underflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2000000000);
    Literal(lit 2000000000);
    BinOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block7, @block8);
  block7:
    Literal(lit -4000000000);
    Jump(@block9);
  block8:
    Literal(lit 294967296);
    Jump(@block9);
  block9:
    Call(count 3, flag true);
    // underflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.5);
    Literal(lit 1);
    BinOp(op '-');
    Literal(lit 0.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0.5);
    BinOp(op '-');
    Literal(lit 1.5);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000000);
    Literal(lit 4999999000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

function testUnaryPlus() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 2);
    Call(count 3, flag true);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 3.1);
    Call(count 3, flag true);
    Literal(lit undefined);
    Return();
}

allocation 6 = {
  isNaN: &function Number_isNaN,
};