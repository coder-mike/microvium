export 0 = &function run;

slot ['global:Infinity'] = Infinity;
slot ['global:NaN'] = NaN;
slot ['global:Number'] = &allocation 2;
slot ['global:assert'] = host function 2;
slot ['global:assertEqual'] = host function 3;
slot ['global:overflowChecks'] = false;
slot testAddition = &function testAddition;
slot testDivision = &function testDivision;
slot testGreaterThan = &function testGreaterThan;
slot testIncrDecr = &function testIncrDecr;
slot testLessThan = &function testLessThan;
slot testMultiplication = &function testMultiplication;
slot testNegate = &function testNegate;
slot testPower = &function testPower;
slot testRemainder = &function testRemainder;
slot testSubtraction = &function testSubtraction;
slot testUnaryPlus = &function testUnaryPlus;

function Array_push() {
  entry:
    LoadArg(index 1);
    LoadVar(index 0);
    LoadArg(index 0);
    LoadArg(index 0);
    Literal(lit 'length');
    ObjectGet();
    LoadVar(index 1);
    ObjectSet();
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function Number_isNaN() {
  entry:
    LoadArg(index 1);
    // NaN is the only value that is not equal to itself
    LoadVar(index 0);
    LoadVar(index 0);
    BinOp(op '!==');
    Return();
}

function run() {
  entry:
    LoadGlobal(name 'testNegate');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testUnaryPlus');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testAddition');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testSubtraction');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testMultiplication');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testDivision');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testLessThan');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testGreaterThan');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testRemainder');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testPower');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    LoadGlobal(name 'testIncrDecr');
    Literal(lit undefined);
    Call(count 1);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testAddition() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '+');
    Literal(lit 5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '+');
    Literal(lit 5000);
    Call(count 3);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 3500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3);
    Pop(count 1);
    // 12 bit addition (should not overflow, but should take the fast path still)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6000);
    Literal(lit 500);
    BinOp(op '+');
    Literal(lit 6500);
    Call(count 3);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 500);
    Literal(lit 6500);
    BinOp(op '+');
    Literal(lit 7000);
    Call(count 3);
    Pop(count 1);
    // 13 bit addition. Does not technically overflow but should take the slow path
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '+');
    Literal(lit 18000);
    Call(count 3);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '+');
    Literal(lit 150000);
    Call(count 3);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7500);
    Literal(lit 7000);
    BinOp(op '+');
    Literal(lit 14500);
    Call(count 3);
    Pop(count 1);
    // overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2000000000);
    Literal(lit 2000000000);
    BinOp(op '+');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block4, @block5);
  block4:
    Literal(lit 4000000000);
    Jump(@block6);
  block5:
    Literal(lit -294967296);
    Jump(@block6);
  block6:
    Call(count 3);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1.5);
    Literal(lit 1);
    BinOp(op '+');
    Literal(lit -0.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit 0.5);
    BinOp(op '+');
    Literal(lit -1.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -5000000000);
    Literal(lit 4999999000);
    BinOp(op '+');
    Literal(lit -1000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testDivision() {
  entry:
    // Floating point division (the normal)
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op '/');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op '/');
    Literal(lit 3.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op '/');
    Literal(lit 3.4);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 3);
    Pop(count 1);
    // Without overflow checks enabled, the negation of integer zero is integer zero
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '-');
    UnOp(op '-');
    BinOp(op '/');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block13, @block14);
  block13:
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Jump(@block15);
  block14:
    LoadGlobal(name 'global:Infinity');
    Jump(@block15);
  block15:
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op '/');
    LoadGlobal(name 'global:Infinity');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op '/');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    // Integer division
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit -3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit -2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit -2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -6);
    Literal(lit 3);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7);
    Literal(lit 2);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8.5);
    Literal(lit 2.5);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit -3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -0);
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:NaN');
    LoadGlobal(name 'global:NaN');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:Infinity');
    LoadGlobal(name 'global:Infinity');
    BinOp(op 'DIVIDE_AND_TRUNC');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testGreaterThan() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '>=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testIncrDecr() {
  entry:
    Literal(lit 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    LoadVar(index 3);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 4);
    StoreVar(index 0);
    Pop(count 1);
    Literal(lit 3);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    Literal(lit 1.5);
    LoadVar(index 1);
    StoreVar(index 0);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '+');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 2.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadVar(index 0);
    Literal(lit 1);
    BinOp(op '-');
    LoadVar(index 3);
    StoreVar(index 0);
    Literal(lit 1.5);
    Call(count 3);
    Pop(count 1);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testLessThan() {
  entry:
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    // Integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Negative integers
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2);
    Literal(lit -2);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    // Floating point
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 1.1);
    BinOp(op '<=');
    Literal(lit false);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.1);
    Literal(lit 2.1);
    BinOp(op '<=');
    Literal(lit true);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testMultiplication() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5.5);
    Literal(lit 6);
    BinOp(op '*');
    Literal(lit 33);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit 30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit -6);
    BinOp(op '*');
    Literal(lit -30);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000);
    Literal(lit 5000);
    BinOp(op '*');
    Literal(lit 25000000);
    Call(count 3);
    Pop(count 1);
    // Overflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 17000);
    Literal(lit 2);
    BinOp(op '*');
    Literal(lit 34000);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000);
    Literal(lit 5000000);
    BinOp(op '*');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block10, @block11);
  block10:
    Literal(lit 25000000000000);
    Jump(@block12);
  block11:
    Literal(lit -1004630016);
    Jump(@block12);
  block12:
    Call(count 3);
    Pop(count 1);
    // Overflow 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 25000000000000);
    Literal(lit 1);
    BinOp(op '*');
    Literal(lit 25000000000000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testNegate() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -1);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '-');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    LoadGlobal(name 'global:Infinity');
    UnOp(op '-');
    Literal(lit -1.1);
    Literal(lit 0);
    BinOp(op '/');
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2147483648);
    UnOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block1, @block2);
  block1:
    Literal(lit 2147483648);
    Jump(@block3);
  block2:
    Literal(lit -2147483648);
    Jump(@block3);
  block3:
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testPower() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 3);
    BinOp(op '**');
    Literal(lit 8);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0);
    BinOp(op '**');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.5);
    Literal(lit 1);
    BinOp(op '**');
    Literal(lit 2.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 1);
    LoadGlobal(name 'global:Infinity');
    BinOp(op '**');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testRemainder() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 550);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit 3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -8);
    Literal(lit -3);
    BinOp(op '%');
    Literal(lit -2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2.25);
    Literal(lit 1);
    BinOp(op '%');
    Literal(lit 0.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5.25);
    Literal(lit 2);
    BinOp(op '%');
    Literal(lit 1.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 550.25);
    Literal(lit 100);
    BinOp(op '%');
    Literal(lit 50.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit 4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit 3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7.25);
    Literal(lit -4);
    BinOp(op '%');
    Literal(lit -3.25);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 5);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    LoadGlobal(name 'global:assert');
    Literal(lit undefined);
    LoadGlobal(name 'global:Number');
    LoadVar(index 2);
    Literal(lit 'isNaN');
    ObjectGet();
    LoadVar(index 2);
    Literal(lit 5.1);
    Literal(lit 0);
    BinOp(op '%');
    Call(count 2);
    StoreVar(index 2);
    Call(count 2);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testSubtraction() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3);
    Literal(lit 2);
    BinOp(op '-');
    Literal(lit 1);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 3000);
    Literal(lit 2000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3);
    Pop(count 1);
    // out of 8 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 10000);
    Literal(lit 8000);
    BinOp(op '-');
    Literal(lit 2000);
    Call(count 3);
    Pop(count 1);
    // out of 14 bit signed range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 80000);
    Literal(lit 70000);
    BinOp(op '-');
    Literal(lit 10000);
    Call(count 3);
    Pop(count 1);
    // out of 16 bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -7500);
    Literal(lit 7000);
    BinOp(op '-');
    Literal(lit -14500);
    Call(count 3);
    Pop(count 1);
    // underflow 14-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit -2000000000);
    Literal(lit 2000000000);
    BinOp(op '-');
    LoadGlobal(name 'global:overflowChecks');
    Branch(@block7, @block8);
  block7:
    Literal(lit -4000000000);
    Jump(@block9);
  block8:
    Literal(lit 294967296);
    Jump(@block9);
  block9:
    Call(count 3);
    Pop(count 1);
    // underflow signed 32-bit range
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.5);
    Literal(lit 1);
    BinOp(op '-');
    Literal(lit 0.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 2);
    Literal(lit 0.5);
    BinOp(op '-');
    Literal(lit 1.5);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 5000000000);
    Literal(lit 4999999000);
    BinOp(op '-');
    Literal(lit 1000);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

function testUnaryPlus() {
  entry:
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1);
    Literal(lit 1);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 2);
    Call(count 3);
    Pop(count 1);
    LoadGlobal(name 'global:assertEqual');
    Literal(lit undefined);
    Literal(lit 1.1);
    Literal(lit 2);
    BinOp(op '+');
    UnOp(op '+');
    Literal(lit 3.1);
    Call(count 3);
    Pop(count 1);
    Literal(lit undefined);
    Return();
}

allocation 2 = {
  isNaN: &function Number_isNaN,
};

allocation 3 = {
  push: &function Array_push,
};